# 영속성 컨텍스트

## 서론

ORM : 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 것<br>
Hibernate : ORM 기술에 대한 명세인 JPA의 구현체 중 하나<br>
<br>
DB와 자바 코드를 연결!

## EntityManager

엔티티를 저장, 수정, 삭제, 조회하는 말그대로 매니저<br>
동시성 문제로 인해 여러 쓰레드 간에 공유되어서는 안된다

## 영속성 컨텍스트

EntityManager를 통해서 엔티티를 영속성 컨텍스트에 저장한다<br>

### 엔티티의 4가지 상태

1. 비영속<br>
영속성 컨텍스트와 전혀 상관없는 상태<br>
단순히 인스턴스만 생성했고 영속성 컨텍스트나 DB와 전혀 관련이 없는 상태
```java
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");
```

2. 영속<br>
엔티티 매니저를 통해 영속성 컨텍스트에 저장된 상태<br>
영속성 컨텍스트의 관리 아래에 놓이게 된다.
```java
@Autowired EntityManager em;
em.persist(member);
```

3. 준영속<br>
영속 상태였던 엔티티가 영속성 컨텍스트의 관리를 받지 않게 된 상태
```java
em.detach(member);
```

4. 삭제<br>
삭제가 삭제지 뭐야...
```java
em.remove(member);
```

### 특징

1. 영속성 컨텍스트 내에서는 엔티티를 식별자 값으로 구분하기 때문에 식별자 값이 반드시 있어야 한다.
2. 영속성 컨텍스트의 데이터를 DB에 저장(반영)하는 것을 flush라고 한다.
    - em.flush()로 직접 flush
    - 트랜잭션 커밋 시
    - JPQL 쿼리 실행 시
3. 영속성 컨텍스트의 장점
    - 1차 캐시
    - 동일성 보장
    - 트랜잭션 쓰기 지연
    - 변경 감지
    - 지연 로딩

## CRUD에서의 영속성 컨텍스트
create : 1차 캐시에 저장하면서 쓰기 지연 SQL 저장소에 insert sql을 쌓아뒀다가 커밋할 때 한번에 sql문을 날려 DB에 반영<br>
read : 1차 캐시에서 조회해보고 없으면 DB에서 조회해서 1차 캐시에 저장<br>
update : 1차 캐시에 저장된 엔티티 값을 수정하면 해당 엔티티의 변경사항을 DB와 비교하여 자동으로 반영(변경 감지)<br>
delete : 엔티티 삭제 후 delete sql을 쌓아뒀다가 DB에 반영<br>

## 준영속
영속->준영속으로 바꾸는 세 가지 방법
1. em.detach(entity)
2. em.clear()
3. em.close()

주로 영속성 컨텍스트가 종료되면서 준영속 상태가 되고, 개발자가 직접 준영속 상태로 만드는 일은 드물다.<br>
준영속 상태의 엔티티는 지연 로딩이 불가능하다.<br>
<br>
준영속(&비영속)->영속으로 바꾸는 방법
- em.merge(entity)